# java 基础
 - ###### **1什么是多态：**
    -  多态的定义：不同类的对象对同一消息作出不同的响应（同一事件发生在不同的对象间产生不同的结果），
    根据发送对象的不同，采用多种不同的行为方式
    -  动态绑定：是指运行期间才知道对象的实际类型，根据实际类型调用其相对应的方法
    - 多态存在的三个必要条件
      -  要有继承 
      -  要有重写
      - 父类引用指向子类对象
- ###### **2 String 和 StringBuffer的区别：**
     -  简单地说，StringBuffer对象的内容是可以修改的；而String对象一旦产生就不可以被修改，重新赋值
     其实是两个对象。
     -  StringBuffer在进行字符串的处理时候，是不生成新的对象，在内存上要优于Stirng类，所以在实际的使用
     ，如果经常需要对一个字符串进行修改，使用、stringBuffer更加合适些。StringBuffer类是一种辅助类，
     可以预先分配指定长度的内存块建立一个字符串缓冲区。这样使用StingBuffer类的append方法追加字符，比String
     使用+操作符，每一次添加到一个字符串时，字符串对象都需要重新找一个新的内存空间来容纳更大的字符串，这是
     一个非常消耗时间的操作，添加一个字符就意味着要一次又一次的对字符串重新分配内存
     - StringBuffer 是内存安全的 
- ###### **3 什么是线程同步：**
     -  当使用多个线程来访问同一个数据时候，容易引发出线程安全的问题（可能引发的数据的不一致问题）
     - _解决方法_：1 同步代码块：synchronized(对象){}
                 2 同步方法：public synchronized 数据的返回类型 方法名称（）{}
     - 同步方法的同步监视器为this 该对象自己本身（调用同步方法的对象） 
     - synchronized：可以修饰代码块，可以修饰方法，但是不可以修饰构造器和属性
     - 同步机制应该注意的点：
       - 1 安全性高，但是性能低，在多线程中使用。
       - 2 只需要对那些会改变共享资源的方法进行同步
       -  3 在单线程环境中，使用不安全的版本（没有同步的方法和代码块）以保证性能，在多线程中使用线程安全的版本
       
- ###### **4 进程 和 线程：**       

     - 进程的三个特点：
        -  独立性 进程是系统中独立存在的实体，他可以独立拥有资源，有独立的地址空间。用户进程不可以直接访问其他进程的地址空间。
        -   动态性 进程和程序的区别在于进程是动态的，进程中有时间的概念，进程具有自己的生命周期和各种不同的状态。
        - 并发性 多个进程可以在单个处理器上并发执行，互不影响。
    - 线程：
           简述： 线程是进程的组成部分，一个进程可以有多个线程。而一个线程必须拥有一个父进程。线程可以有自己的堆栈，自己的程序计数器和自己的局部变量，
           但是，不能拥有系统的资源。他和父进程的其他线程共享所有的资源。
     - 线程的特点：
        - 线程是独立运行的，其不知道进程中是否还有其他线程的存在
        -  线程的执行时抢占式的。
        - 线程是可以完成一定的任务，可以和其他线程共享父进程的共享变量和部分环境，相互协作来完成任务。
     
     - 进程的三种基本状态：
        - 就绪状态（Ready）
        - 执行状态（Running）
        -  阻塞状态（Blocked）
    -  三种情况引起的阻塞：
         - 等待阻塞：
                                  运行的线程执行wait()方法，该线程会释放占有的所有资源，jvm会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，
                               必须依靠其他线程调用notify()或者notifyAll()方法，才能被唤醒。
          - 同步阻塞：
                                  运行的线程在获取对象的同步锁时，若该同步锁被其他的线程占有，则jvm会把线程放入“锁池中”。
          -  其他阻塞:
                                  运行的线程执行sleep()或者其他线程join()，或者发出I/O请求时，jvm会把该线程设置为阻塞的状态。当sleep()状态超时，join()等待
                               进程终止或者超时，或者I/O处理时间完毕，线程重新进入到就绪状态。
    - 同步机制：
        - 临界区(Critical Section):保证在某一个时刻只有一个线程能访问数据的简便方法。
        - 互斥量(Mutex):只有拥有互斥对象的线程才具有访问资源的权限。（为协调共同对一个共享资源的单独访问而设计的）
        - 信 号量(Semaphores):为控制一个具有有限数量的用户资源而设计的。
        - 事件(Event):事件对象也可以通关过通知操作的方式来保持线程的同步。并且可实现不同进程中的线程同步操作。
 - ######  **5 Lock 和 Synchronized 的区别：**  
   - Lock 是一个接口， synchronized 是Java中的一个关键字
   -  synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象的发生。而lock在发生异常的时候，如果没有主动通过unLock()去释放，则会造成死锁的现象，
    所以在使用它的时候，需要在finally块中释放锁。
    - Lock可以让等待锁的线程响应中断，而synchronized却不行（线程就这么一直等下去）。
    - 通过lock 可以知道有没有成功获得锁，而synchronized却不行。
    - 当资源的竞争很强烈的时候，此时lock的性能要远远优于synchronized.
   
   
   
 - ###### **6 常见的内存溢出：** 
 
 
 - ###### **7 重载和重写的区别：** 
   - 重载： 发生在同一类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法的返回值和访问修饰符可以不同
    - 重写： 发生在父子类中，方法名，方法的参数列表必须相同，返回的值<=父类
                                                       抛出的异常<=父类
                                                       访问的修饰符>=父类（如果父类的访问修饰符为private,则子类中就不是重写）
                                       
 - ###### **8 构造器Constructor是否能被override：**   
    -  答：不能
         构造器不能被重写，不能被用为static,只能是public protected private 三种权限的修饰符，且不能有返回值。
        
         
         
 - ###### **9 public protected private ：** 
 
     -   public 在任何地方都能被访问
     - protected 在同包内的类以及包外的子类才能被访问
      -  private 只有在本类中才能被访问
       
       
  -  ###### **10 自动住装箱和拆箱：**  
     - 1装箱：将基本类型用他们对应的引用类型包装起来。
      -  2拆箱: 将包装类型转换成基本的数据类型。
      -  java 编译器会在编译期根据语法决定是否进行拆箱和装箱动作。
       
       
  - ###### **11 Error和Exception 的区别：**  
       -  1 Error 和 Exception类都是throwable 类的子类
       -  2 区别：
               1 Error 类一般指与虚拟机相关的问题，如系统奔溃，虚拟机错误，内存空间不足，方法调用栈溢出。对于这类错误的导致的
            应用程序中断，仅靠程序本身无法恢复和防御，遇见这样的问题，建议让程序终止。
               2 Exception 类表示程序可以处理异常，可以捕获而且可能恢复。遇见这类异常，应该尽可能处理异常，使程序恢复正常运行。
       - 3 引申
         -  unchecked :
                         1 指的是程序的瑕疵或者逻辑错误，并且在运行时无法恢复。
                         2 包括Error 或者 RuntimeException 及其子类 如：OutOfMemoryError NullPointerException IndexOutOfBoundException等
                         3 语法上不需要申明抛出异常
                   
         -   checked : 
                         1 代表程序不能直接控制的无效外界情况（数据库问题，网络异常等）
                         2 ClassNotFoudException SQLException
                         3 需要try catch 处理或者throws申明抛出的异常
  - ###### **12 java中如何实现代理机制**   
      - 1 jdk动态代理：代理类和目标类实现了共同的接口->InvocationHandler
      -  2 CGLIB动态代理：代理类是目标类的子类，用到MethodInterceptor
 -  ###### **13 死锁的产生和预防** 
      -  产生死锁的四个必要条件：
         - 互斥条件：所谓的互斥就是在某一时间独占资源
         -  请求与保持条件：一个进程因请求资源而阻塞时，对以获得的资源不放
         - 不可剥夺条件：进程以获得资源，在未使用完之前，不能强行剥夺。
         -  循环等待条件：若干线程之间形成了一种头尾相接的循环等待资源关系。
     -  死锁的预防：
        -  打破互斥条件：允许进程同时访问某些资源。但是有些资源却不能被同时访问的，如打印机。
        -  打破不可抢占的条件：即进程可以强行从占有者那里剥夺某些资源。:当一个进程已经占有某些资源，他又申请资源，但是不能及时被满足，那么
                  它将释放所占有的资源，以后再重新申请。它释放的资源可重新分配给其他的线程。这种死锁的方法实现起来困难，会降低系统的性能。
         -  打破占有且申请条件。可以实现资源预先分配策略，即进程在运行前一次性地向系统申请所有需要的全部资源。如果某个线程的全部资源得不到满足
                  ，则不给分配资源，此进程暂不运行。
         -   打破循环等待的条件：实行资源的有序分配策略，采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占有资源不会形成环路，进程的
                  占有了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。
 -  ###### **14 序列化 和 反序列化**  
     - 序列化: 把对象转化为字节序列的过程。
    - 反序列化： 把字节序列恢复为对象的过程。
    - 对象序列化的用途：
        -  把对象的字节序列永久地保存在硬盘上，通常保存在一个文件中。
         - 在网络上传送对象的字节序列
                                  当两个进程在进行远程通信的时候，彼此可以发送各种类型的数据，都会以二进制序列的形式在网络上传送，发送方需要把java对象转化为字节序列，
                              接收方则需要把字节序列转化为java对象。
    - 常见的序列化的协议
      - protobuf 
      - Thrift 
       - Hessian 
       - Kryo
        
 -  ###### **15 json 和 xml 的区别**      
    - xml : 
       - 应用广泛，可扩性强，被广泛地应用在各种场合。
       -  读取解析没有 json 快。
         -  可读性强，可描述复杂的结构。
    - json :
       - 结构简单，都是一些键值对。
       -  读取解析的速度比较快，很多语言支持。
        -  传输量比较小，传输速率大大提高
        - 描述复杂的结构的能力比较弱。
                
              

 
