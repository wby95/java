  # java 虚拟机
  -  运行时数据区域
  
       [浏览一下一JAVA内存模型](内存模型.JPG)
       
       [浏览一下一些String字符串在运行时区域的分配情况](尚硅谷.JPG)
     - 注：线程私有：各个线程之间的计数器互不影响，独立存储。
     - 程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器,字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域
     - java 虚拟机栈()：每一个方法的执行的同时都会创建一个栈帧用于存储局部变量表/操作数栈/动态链接/方法出口等信息。每一个方法从调用直到执行完成的过程中，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
        - 局部变量表：存放了编译器可知的各种基本数据类型（boolean/byte/char/short/int/float/long/double）,对象引用（reference类型，它不等同于对象本身，可能是一个指向对象的起始地址的引用指针，也可以是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）
        - 可能抛出：
          - StackOverflowError:请求的栈深度过长；
          - OutOfMemory:扩展无法申请到足够的内存。
     - 本地方法栈:本地方法栈与虚拟机栈所发挥的作用相似。虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用到的Native方法服务。
       - 可能抛出：
          - StackOverflowError
          - OutOfMemory
     - java 堆：jav虚拟机所管理的内存中最大的一块，java堆是内存共享的，（不是绝对）对象实例以及数组都要分配到堆上。
        - 扩展：java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”，现在的收集器基本都是采用分代收集算法，所以java堆中可以细分为：新生代&老年代（后还可细分），堆的采用的垃圾算法后边介绍。
     - 方法区:储存已被虚拟机加载的类信息、常量、静态常量、即使编译器编译后的代码等数据
       - 类信息：如spring使用ioc&aop创建bean时，或者使用cglib反射形成的class信息等。
          - 1 类型的全定名 2 类型的直接超类的全定名 3 类型是类类型还是接口类型 4 类型的访问修饰符
     - 运行时常量：方法区的一部分.类文件除了有类的版本、字段、方法、接口等描述信息外,还有一项是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放. 此外运行时常量池具备动态性.Java不要求常量一定只有编译期才能产生,运行期间也可能将新的常量放入池中,String的intern()方法就是例子.
             会出现的异常状况:OOM(OutOfMemoryError);
  -  内存溢出
  -  垃圾回收算法 
  -  垃圾收集器
  -  类加载的过程访问