 #  高并发程序设计读后感
 
 - 并发的级别
 
   |||并发级别|||
   | :--------  | :--------  |  :--------  |   :--------  | :------|
   |1 阻塞(synchronized&重入锁)|2 无饥饿(无优先级)|3 无障碍，最弱的非阻塞调度(不会因为临界资源而挂起一方)&(一致性的标志，一旦检测到大家一起修改的共享数据，将对自己所做的修改进行回滚)|4 无锁(只要求一个线程可以在有限步内完成操作)|5 无等待(所有的线程都必须在有限步完成)|

- JMM(java的内存模型)<--保证多个线程间能够（数据安全性）&（数据的一致性）有效的、正确协同工作，JMM也就是为此而生的。
  
   ||||
   | :------ | :------| :------|
   |1 原子性：一个操作是不可中断的|2 可见性：当一个线程修改了共享变量，其他线程能否立即知道被修改 不能：（编译器&硬件优化的缘故）&（指令的重排序）|3 有序性：写在后面的代码不一定就是后执行（可能出现指令的重排序）&指令重排序可以保证串行化语义一致，但是没有义务保证多线程间的语义也一致/为毛要流水线？一条指令的执行可以分为很多步骤，有了流水线这个神器，我们的cpu才能够高效地运行&为毛要指令重排？尽量减少中断流水线 见下图|
     
     
     
- 线程状态图

   [线程状态图](b.md)

-线程的基本操作
   - 新建线程
     - 1 new Thread(java 单继承)
     - 2 接口Runnable
   - 终止线程
     - stop():会产生写入的数据正写到一半的时候，强行终止了，<--正在废除中
     - 自定义退出方法即可。    
     - 线程中断：让目标线程停止执行的意思
       ```
          1 public void Thread.interrupt()//中断线程
          2 public boolean Thread.isInterrupted()//是否被中断
          3 public static boolean  Thread.interrupted()//判断是否被中断，并且清除当前中断的状态。
          4 如果中断后，线程立即无条件退出，我们就会遇见stop()方法的老问题。
          5 Thread.sleep()方法由于中断引起的异常，此时，他会清除中断标记，如果不加以处理，下一次循环时候就无法捕获这个中断，所以在异常的处理中再次设置了中断的标志。
       ```
   - 等待(wait)&通知(notify)  
     - 无论是wait()&notify():都首先需要获得目标对象的一个监视器。
     - 这两个方法并不是位于Thread类，而是Object类。
     
       |wait()|sleep()|
       | :------ |  :------ |
       |会释放目标对象的锁|不会释放任何资源|
       |都可以让线程等待若干时间  |
    
  - 挂起suspend()&执行resume()
 
      | 已经被废弃，不推荐使用|
      | :------ |
      |1 因为suspend()在导致线程暂停的同时，并不会去释放任何的资源。|
      |2 如果resume()的操作意外发生在suspend()前的执行了，那么被挂起的线程可能很难有机会继续执行
      |3 一个可靠的suspend()&resume()可以wait()&notify()去实现|
    
  - 等待线程的结束join()&谦让yield()
     
      |join|yield|
      | :------ | :------ |
      |1 public final void join() throws InterruptedException//无限等待，他会一直阻塞当前线程，直到目标线程执行完毕 2 public final synchronized void join(long millis) throws InterruptedException//如果超过了给定时间目标进程还在执行，当前线程也会因为等不及而继续往下执行 join()的本质是让调用线程wait()在当前线程对象的实例上|让出cpu并不表示当前的线程不执行了，当线程让出cpu后，还会去进行cpu资源的争夺，但是能否再次分配到，就不一定了。|
  
- volatile与JMM
      
      |volatile|
      | :------ |
      |1 并不能代表锁，他无法保证一些复合操作的原子性|
      |2 不能随意变动优化目标指令&禁止重排|
      |3 可见性|
      |4 volatile并不能真正的保证线程的安全，他只能保证一个线程修改后，其他线程能够看到这个改动，但是两个线程同时修改某一数据，却仍然会产生冲突|
     
     
- 守护线程
    - 它是系统的守护者，在后台默默地完成一些系统性的服务
    - 当一个java应用内，只有守护线程时，java虚拟机就会自然退出。
    - 设置守护线程必须在线程start()之前设置setDaemon(true);

- 线程的优先级
   - 如果运气不好，高优先级线程可能也会抢占失败。
   - 使用1到10表示线程优先级，数字越大则优先级就会越高。
   
- synchronized
   - 这个关键字的作用是实现线程的同步，他的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证了线程间的安全性。
   
     |synchronized多种用法|
     | :------ |
     |1 指定加锁的对象|
     |2 直接作用于实例方法|
     |3 直接作用于静态的方法|

- 并发下的ArrayList
    - ArrayList是一个线程不安全的容器，当它在扩容过程中，内部的一致性被破坏，两个线程可能同时对ArrayList的同一个位置进行赋值。
    - 改进：可用线程安全的Vector代替ArrayList
    
- 并发下的HashMap(jdk1.7-->出现死循环)
   - 出现死循环的原因：由于多个线程的冲突，链表的结构已经遭到了破坏，当链表成环时，就会出现死循环。
   - 改进：使用ConcurrentHashMap代替hashMap
   
- 错误的加锁
  - Integer.aluesOf返回的是一个代表值的Integer实例。使用时候，应当注意。